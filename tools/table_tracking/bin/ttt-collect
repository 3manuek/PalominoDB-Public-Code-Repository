#!/usr/bin/ruby
require 'rubygems'
require 'yaml'
require 'getoptlong'
require 'open-uri'
require 'text/reform'

require 'pdb/dsn'
require 'ttt/db'
require 'ttt/collector'

opts = GetoptLong.new(
  [ '--help', '-h', GetoptLong::NO_ARGUMENT ],
  [ '--config', '-c', GetoptLong::REQUIRED_ARGUMENT ],
  [ '--dsn', '-d', GetoptLong::REQUIRED_ARGUMENT ],
  [ '--debug', GetoptLong::NO_ARGUMENT ],
  [ '--verbose', GetoptLong::NO_ARGUMENT ],
  [ '--stat', GetoptLong::REQUIRED_ARGUMENT ],
  [ '--list-stats', '-l', GetoptLong::NO_ARGUMENT ]
)

dsn=nil
cfg=nil
debug=false
verbose=false
stat=:all

opts.each do |opt, val|
  case opt
    when '--help'
      puts <<DOC_EOF
== Synopsis

ttt-collect: Run a table tracking collection

== Usage

ttt-collect [--help] --config config.yml --dsn servers.yml

-h, --help:
   This help
--config file, -c file:
   Path to ttt config file.
--debug:
   Make the tool VERY noisy.
--dsn file, -d file:
   Path to PalominoDB dsn.yml
--stat statistic:
   Collect a single <statistic>.
   See --list-stats for available statistics.
--list-stats, -l:
   List available statistics.
DOC_EOF
      exit 1
    when '--config'
      cfg = YAML.load_file(val)
    when '--dsn'
      dsn = Pdb::DSN.new(val)
      dsn.validate
    when '--debug'
      debug=true
    when '--verbose'
      verbose=true
    when '--stat'
      stat=val.to_sym
    when '--list-stats'
      rf=Text::Reform.new
      rf.trim=true
      TTT::Collector.load_all
      cols=TTT::Collector.collectors
      names= cols.map { |c| c.stat }
      descs= cols.map { |c| c.desc }
      puts rf.format("Available statistics:", "[[[[[[[[[[[ - "+ ("["*80), names,descs)
      exit(0)
  end
end

if cfg.nil?
  puts "Must specify configuration."
  puts "Use --help for more."
  exit 1
end
if dsn.nil?
  puts "Must specify dsn."
  puts "Use --help for more."
  exit 1
end

if debug then
  ActiveRecord::Base.logger = ActiveSupport::BufferedLogger.new(STDOUT, ActiveSupport::BufferedLogger::Severity::DEBUG)
else
  ActiveRecord::Base.logger = ActiveSupport::BufferedLogger.new(STDOUT, ActiveSupport::BufferedLogger::Severity::INFO)
end

TTT::Db.open(cfg)
# Creates the database, if it doesn't exist,
# and will upgrade it too!
TTT::Db.migrate

TTT::Collector.verbose = verbose
TTT::Collector.load_all

Runtime=Time.now

begin
  TTT::Snapshot.transaction do
    runs=[]
    hosts=dsn.get_all_hosts.reject { |h| !dsn.host_active? h }
    if stat==:all
      TTT::Collector.each { |c| runs<<c.collect_hosts(hosts, cfg, Runtime);  }
    else
      runs<< TTT::Collector[stat].collect_hosts(hosts, cfg, Runtime)
    end
    runs.flatten!
    txn=TTT::Snapshot.head || -1
    txn+=1
    runs.each do |r|
      r.run_ids.each do |i|
        TTT::Snapshot.create do |snap|
          snap.collector_run_id = r.id
          snap.txn = txn
          snap.run_time = r.last_run
          if i.class == Array
            snap.statistic_id = i[0]
            p_txn=TTT::Snapshot.find_last_by_collector_run_id_and_statistic_id(r.id,i[1])
            unless p_txn.nil?
              snap.parent_txn = p_txn.id
            end
          else
            snap.statistic_id = i
          end
        end
      end
    end
  end
rescue SQLite3::BusyException => e
  puts "Two collectors cannot be running concurrently."
rescue TTT::CollectorRunningError => e
  puts e.message
end
