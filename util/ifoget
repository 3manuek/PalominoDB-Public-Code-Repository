#!/usr/bin/env ruby
require 'rubygems'
require 'net/ssh'
require 'yaml'
require 'keybox'
require 'set'
require 'highline'
require 'fileutils'
require 'tempfile'
require 'timeout'
require 'ruby-debug'

## Monkey patch the find method to test key restrictions first
## This fixes the bug with boolean values. The better solution
## is to explicitly call .to_s on them, but, this works pretty well.
#module Keybox
#  module Storage
#    class Container
#    end
#  end
#end

class AppConfig < Keybox::Storage::Record
  def [](key)
    self.data_members[key.to_sym]
  end

  def []=(k,v)
    self.data_members[k.to_sym] = v
  end
end

class AppStorage < Keybox::Storage::Container
  attr_reader :config
  def initialize(pw, path)
    @config ||= AppConfig.new
    super(pw, path)
  end
  def find(search_string,restricted_to = nil)
    case search_string
    when Regexp
      regex = Regexp.new(search_string.source,search_string.options | Regexp::IGNORECASE)
    else
      regex = Regexp.new(search_string.to_s,Regexp::IGNORECASE)
    end
    matches = []
    @records.each do |record|
      restricted_to = restricted_to || ( record.data_member_names - %w(password) )
      record.data_members.each_pair do |k,v|
        if restricted_to.include?(k.to_s) and regex.match(v)  then
          matches << record
          break
        end
      end
    end
    return matches
  end
  def save(path = @path)
    calculate_records_digest
    encrypt_records
    tmp=Tempfile.new($0)
    tmp.write(self.to_yaml)
    tmp.fsync
    FileUtils.mv(tmp.path, @path)
    tmp.close!
    @config.modified = false
    @records.each do |record|
      record.modified = false
    end
    @modified = false
  end

  def for_edit(group=nil)
    d={}
    d['config'] = {}
    @config.data_members.each do |k,v|
      d['config'][k.to_s] = v
    end
    @records.each do |g|
      next unless group.nil? or g.groupname == group
      group_cfg = {}
      g.data_member_names.sort.each do |dm|
        next if dm == 'groupname'
        group_cfg[dm] = g[dm]
      end
      unless g.records.nil? 
        g.records.each do |h|
          group_cfg['hosts'] ||= {}
          group_cfg['hosts'][h.hostname] = {}
          h.data_member_names.each do |dm|
            next if dm == 'hostname'
            group_cfg['hosts'][h.hostname][dm] = h[dm]
          end
        end
      end
      d[g.groupname] = group_cfg
    end
    d.to_yaml
  end
  def from_edit(opts)
    opts['config'].each do |k,v|
      @config[k] = v
    end
    opts.delete 'config'
    opts.each do |group,groupd|
      record_group = self.find(group, ['groupname'])[0]
      if record_group.nil?
        record_group=KeyGroup.new(group)
        self<<record_group
      end
      hosts=groupd['hosts']
      groupd.delete 'hosts'
      groupd.each do |k,v|
        record_group[k] = v
      end
      hosts.each do |host,hostd|
        record_host=record_group.find(host)
        if record_host.nil?
          record_host=Server.new(host)
          record_group<<record_host
        end
        hostd.each do |k,v|
          record_host[k]=v
        end
      end
    end
  end
  private
  def encrypt_records
    cipher     = OpenSSL::Cipher::Cipher.new(self.records_cipher_algorithm)
    cipher.encrypt
    cipher.key = calculated_key
    cipher.iv  = self.records_init_vector
    self.records_encrypted_data  = cipher.update(@records.to_yaml + "\n" + @config.to_yaml) 
    self.records_encrypted_data << cipher.final
  end

  def calculate_records_digest
    digest = Keybox::Digest::CLASSES[self.records_digest_algorithm]
    self.records_digest = digest.hexdigest(self.records_digest_salt + @records.to_yaml + "\n" + @config.to_yaml)
  end

  def load_records
    YAML.load_documents(@decrypted_yaml) do |ydoc|
      if ydoc.class == Array
        @records = ydoc
      elsif ydoc.class == AppConfig
        @config = ydoc
      else
        raise ArgumentError, "Invalid configuration"
      end
    end
  end
  #def validate_decryption
  #  debugger
  #  super
  #end
end

class KeyGroup < Keybox::Storage::Record
  attr_reader :records
  def initialize(groupname)
    super()
    self.groupname = groupname
    @records = []
  end

  def [](key)
    self.data_members[key.to_sym]
  end

  def []=(k,v)
    self.data_members[k.to_sym] = v
  end

  def all
    @records
  end

  def find(name)
    srv=nil
    @records.each do |s|
      srv = s  if s.hostname == name
      break if srv
    end
    srv
  end

  def has?(server)
    has=false
    @records.each do |s|
      has = s == server
      break if has
    end
    has
  end

  def <<(obj)
    @records << obj
  end

  def delete(obj)
    @records.delete obj
  end

  def save
    @records.each { |r| r.modified = false }
    super
  end

  def to_yaml_properties
    %w{ @creation_time @modification_time @last_access_time @data_members @records @uuid }
  end
end



class Server < Keybox::Storage::Record
  def initialize(servername)
    super()
    self.hostname = servername
    self.logs = []
  end

  def [](key)
    self.data_members[key.to_sym]
  end

  def []=(k,v)
    self.data_members[k.to_sym] = v
  end

  def ==(o)
    if o.class == Server
      self.hostname == o.hostname
    elsif o.class == String
      self.hostname == o
    end
  end

end


def sudo_exec(ssh,password,cmd, user='root')
  # the built in ssh.exec wraps some stuff up for us, but to catch sudo we
  # have to construct the whole thing ourselves, starting with the channel.
  channel = ssh.open_channel do |channel|
    # now we request a "pty" (i.e. interactive) session so we can send data
    # back and forth if needed. it WILL NOT WORK without this, and it has to
    # be done before any call to exec.
    channel.request_pty do |ch, success|
      raise "Could not obtain pty (i.e. an interactive ssh session)" if !success
    end

    channel.exec("sudo -p pass: -u #{user} #{cmd}") do |ch, success|
      # 'success' isn't related to bash exit codes or anything, but more
      # about ssh internals (i think... not bash related anyways).
      # not sure why it would fail at such a basic level, but it seems smart
      # to do something about it.
      abort "could not execute command" unless success

      # on_data is a hook that fires when the loop that this block is fired
      # in (see below) returns data. This is what we've been doing all this
      # for; now we can check to see if it's a password prompt, and
      # interactively return data if so (see request_pty above).
      channel.on_data do |ch, data|
        if data == "pass:"
          channel.send_data "#{password}\n"
        else
          # ssh channels can be treated as a hash for the specific purpose of
          # getting values out of the block later
          #channel[:result] ||= ""
          #channel[:result] << data
          yield(ch,data)
        end
      end

      channel.on_extended_data do |ch, type, data|
        raise "SSH command returned on stderr: #{data}"
      end
    end
  end
end

def collect_logs(ccfg, args)
  group=args.shift
  if group.nil?
    raise ArgumentError, "Need group."
  end
  verbose=false
  if ['-v', '--verbose'].include? args[0]
    verbose=true
    args.shift
  end

  g=ccfg.find(group, ['groupname'])[0]

  if g.nil?
    raise RuntimeError, "Invalid group."
  end
  jumpthread=nil
  if g.jumpbox
    keys={}
    if g.jump_password and g.jump_ssh_key
      keys[:keys] = [g.jump_ssh_key].flatten
    elsif g.jump_password
      keys[:password] = g.jump_password
    elsif g.password
      keys[:password] = g.password
    elsif g.ssh_key
      keys[:keys] = [g.ssh_key].flatten
    end
    jumpssh=Net::SSH.start(g.jumpbox, (g.jump_username || g.username), keys)
  end
  g.all.each do |srv|
    ssh_args = {}
    hostname = srv.hostname
    if g.jumpbox
      begin
        jumpssh.forward.cancel_local(8888)
      rescue Exception => e
        puts e
      end
      jumpssh.forward.local(8888, srv.hostname, 22)
      ssh_args[:port] = 8888
      ssh_args[:paranoid] = false
      hostname='localhost'
      jumpthread=Thread.new { jumpssh.loop(0.1) { true } }
    end
    username=(srv.username || g.username)
    password=(srv.password || g.password)
    ssh_key=(srv.ssh_key || g.ssh_key)
    use_sudo=(srv.use_sudo || g.use_sudo)

    if password
      ssh_args[:password] = password
    end
    if ssh_key
      ssh_args[:keys] = [ssh_key]
    end

    begin
      ssh=Net::SSH.start(hostname, username, ssh_args)
      puts "============= #{group} #{srv.hostname} ============="
      #if srv.logs
      #  if verbose
      #    puts "DEBUG: cmd: tail -n100 #{srv.logs.to_a.join(' ')}"
      #  end
      #  if use_sudo
      #    sudo_exec(ssh, password, "tail -n100 #{srv.logs.to_a.join(' ')}") do |ch, data|
      #      out<<data
      #    end
      #  else
      #    ssh.exec("tail -n100 #{srv.logs.to_a.join(' ')}") do |ch, stream, data|
      #      if stream == :stdout
      #        out<<data
      #      end
      #    end
      #  end
      #end

      outs={}
      if srv.cmds
        srv.cmds.to_a.each do |c|
          puts "DEBUG: cmd: #{c}" if verbose
          if use_sudo
            sudo_exec(ssh, password, c) do |ch, data|
              outs[c] ||= ""
              outs[c] << data
            end
          else
            ssh.exec(c) do |ch, stream, data|
              outs[c] ||= ""
              outs[c] << data
            end
          end 
        end # cmds loop
      end # if srv has commands

      ssh.loop(0.1)
      outs.each_value do |v|
        v.gsub!(/^/m, '   ')
        puts v
        puts ""
      end
    rescue Errno::ETIMEDOUT => e
      puts "============= ERROR: Timed out while trying to contact #{srv.hostname} ================"
    end
  end
end

def edit_config(ccfg, args)
  group=args.shift
  t=Tempfile.new($0)
  # Convert records to a more natural style
  t.write(ccfg.for_edit(group))
  t.flush
  editor=(ENV['EDITOR'] || ENV['VISUAL'])
  begin
    Timeout::timeout(ccfg.config['max_edit_time']) {
      system("#{editor} #{t.path}")
    }
    t.open
    ccfg.from_edit(YAML.load(t))
    t.close
  rescue Timeout::Error
    puts "\nYour editing session timed out."
    t.close!
  end
end

def show_config(ccfg, args)
  group = args.shift

  puts "application config:"
  ccfg.config.data_member_names.sort.each do |dm|
    puts "  #{dm}: #{ccfg.config[dm]}"
  end

  ccfg.records.each do |g|
    next unless group.nil? or g.groupname == group
    raise ArgumentError, "Invalid structure" unless g.class == KeyGroup
    puts "group: #{g.groupname}"
    g.data_member_names.sort.each do |dm|
      next if dm == 'groupname'
      puts "   #{dm}: #{g[dm]}"
    end
    puts ""
    unless g.records.nil? 
      g.records.each do |h|
        puts "     host: #{h.hostname}"
        h.data_member_names.sort.each do |dm|
          next if dm == 'hostname'
          v=h[dm]
          if v.class == Array
            puts "         #{dm}: #{v.sort.join(',')}"
          else
            puts "         #{dm}: #{v}"
          end
        end
      end
    else
      puts "      No hosts defined."
    end
  end
end

def parse_args(args)
  g = {}
  args.each do |a|
    k,v = a.split(/\s*=\s*/)
    if v.downcase == 'true'
      v = true
    elsif v.downcase == 'false'
      v = false
    elsif v.downcase == 'nil'
      v = nil
    elsif v.include? ',' # If it's got a comma, it's an array. Period.
      v = v.split(',')
    end
    g[k] = v
  end
  g
end

def add_group(ccfg, args)
  group = args.shift
  raise ArgumentError, "Group name mandatory." if group.nil?

  puts "Adding group: #{group}"

  g=KeyGroup.new(group)
  parse_args(args).each do |k,v|
    g[k] = v
  end

  unless ccfg.find(group, 'groupname').nil?
    ccfg << g
    ccfg.save
  end
  g
end

def add_server(ccfg, args)
  group = args.shift
  servername = args.shift
  raise ArgumentError, "Group name mandatory." if group.nil?
  raise ArgumentError, "Host name mandatory." if servername.nil?
  puts "Adding server #{group}.#{servername}"
  s=Server.new(servername)
  parse_args(args).each do |k,v|
    s[k] = v
  end

  g=ccfg.find(group, 'groupname')[0]
  unless g.nil?
    g << s unless g.has? servername
  else
    g=add_group(ccfg,[group])
    g << s
  end
  ccfg.save
  s
end

def del_group(ccfg, args)
  group = args.shift
  raise ArgumentError, "Group name mandatory." if group.nil?
  puts "Deleting group #{group}"
  g=ccfg.find(group, 'groupname')[0]
  unless g.nil?
    ccfg.delete g
  end
  g
end

def del_server(ccfg, args)
  group = args.shift
  hostname = args.shift
  raise ArgumentError, "Group name mandatory." if group.nil?
  raise ArgumentError, "Host name mandatory." if hostname.nil?
  puts "Deleting server #{group}.#{servername}"
  g=ccfg.find(group, 'groupname')[0]
  if g.nil?
    raise ArgumentError, "Invalid group."
  end
  srv = g.find(hostname)
  g.delete srv
  srv
end

def mod_group(ccfg, args)
  group = args.shift
  raise ArgumentError, "Group name mandatory." if group.nil?
  g=ccfg.find(group, 'groupname')[0]
  if g.nil?
    raise ArgumentError, "Invalid group."
  end
  parse_args(args).each do |k,v|
    if v.nil?
      g.data_members.delete k.to_sym
    else
      g[k] = v
    end
  end
end

def mod_server(ccfg, args)
  group = args.shift
  hostname = args.shift
  raise ArgumentError, "Group name mandatory." if group.nil?
  raise ArgumentError, "Host name mandatory." if hostname.nil?
  g=ccfg.find(group, 'groupname')[0]
  if g.nil?
    raise ArgumentError, "Invalid group."
  end
  s=g.find(hostname)
  if s.nil?
    raise ArgumentError, "Invalid server."
  end
  parse_args(args).each do |k,v|
    if v.nil?
      s.data_members.delete k.to_sym
    else
      s[k] = v
    end
  end
end

hline=HighLine.new
pw=hline.ask('Password for config: ') { |q| q.echo = false }

ccfg=AppStorage.new(pw, 'ccollect.yml')

action=ARGV.shift

case action
when 'collect'
  collect_logs ccfg, ARGV
when 'get'
  collect_logs ccfg, ARGV
when 'edit'
  edit_config ccfg, ARGV
when 'show'
  show_config ccfg, ARGV
when 'addgroup'
  add_group ccfg, ARGV
when 'delgroup'
  del_group ccfg, ARGV
when 'addserver'
  add_server ccfg, ARGV
when 'delserver'
  del_server ccfg, ARGV
when 'modgroup'
  mod_group ccfg, ARGV
when 'modserver'
  mod_server ccfg, ARGV
when 'changepw'
  npw=hline.ask('New password: ') { |q| q.echo = false }
  ccfg.passphrase = npw
  ccfg.save
else
  puts <<EOD
  Usage: ifoget <action> [arguments...]

  ACTIONS:
    collect <group>                collect logs for <group>.
    show [group]                   show configuration for [group], or all.
    addgroup  <group> ...          add a new group.
    addserver <group> <server>     add a server to a group.
    delgroup <group>               delete a group and all servers.
    delserver <group> <server> ... delete a server from a group.
    modgroup <group> ...           modify group properties.
    modserver <group> <server> ... modify server properties.
EOD
end

ccfg.save
